import Foundation
import Hummingbird
import HTTPTypes
import Logging

struct ServerSettings {
  let hostname: String
  let port: Int
}

struct AssetBundle {
  let assetRoots: [URL]

  init(moduleName: String) {
    let fileManager = FileManager.default
    var candidates: [URL] = []

    if let bundleURL = Bundle.module.resourceURL?.appendingPathComponent("assets") {
      candidates.append(bundleURL)
    }

    if let bundleURL = Bundle.module.resourceURL {
      candidates.append(bundleURL)
    }

    let executableURL = URL(fileURLWithPath: CommandLine.arguments[0])
    let executableDir = executableURL.deletingLastPathComponent()
    candidates.append(executableDir.appendingPathComponent("assets"))

    let cwd = URL(fileURLWithPath: fileManager.currentDirectoryPath)
    let sourceAssets = cwd
      .appendingPathComponent("Sources")
      .appendingPathComponent(moduleName)
      .appendingPathComponent("Resources")
      .appendingPathComponent("assets")
    candidates.append(sourceAssets)

    let existing = candidates.filter { candidate in
      fileManager.fileExists(atPath: candidate.appendingPathComponent("index.html").path)
    }

    assetRoots = existing.isEmpty ? candidates : existing
  }

  func mimeType(for path: String) -> String {
    let ext = (path as NSString).pathExtension.lowercased()
    switch ext {
    case "html", "htm":
      return "text/html"
    case "css":
      return "text/css"
    case "js":
      return "application/javascript"
    case "json":
      return "application/json"
    case "png":
      return "image/png"
    case "jpg", "jpeg":
      return "image/jpeg"
    case "gif":
      return "image/gif"
    case "svg":
      return "image/svg+xml"
    case "ico":
      return "image/x-icon"
    case "woff":
      return "font/woff"
    case "woff2":
      return "font/woff2"
    case "ttf":
      return "font/ttf"
    default:
      return "application/octet-stream"
    }
  }

  func loadAsset(path: String) -> (data: Data, mimeType: String)? {
    let normalized = normalizedPaths(for: path)

    for root in assetRoots {
      for candidate in normalized {
        let fullPath = root.appendingPathComponent(candidate)
        if let data = try? Data(contentsOf: fullPath) {
          let mime = mimeType(for: candidate)
          return (data, mime)
        }
      }
    }

    return nil
  }

  private func normalizedPaths(for rawPath: String) -> [String] {
    var path = rawPath
    if path.hasPrefix("/") {
      path = String(path.dropFirst())
    }

    if path.isEmpty {
      path = "index.html"
    }

    var candidates = [path]
    if path.hasPrefix("assets/") {
      candidates.append(String(path.dropFirst("assets/".count)))
    }

    return candidates
  }
}

func resolveServerSettings() -> ServerSettings {
  let env = ProcessInfo.processInfo.environment
  let hostname = env["VELOX_SERVER_HOST"] ?? "127.0.0.1"
  let port = Int(env["VELOX_SERVER_PORT"] ?? "") ?? 8080
  return ServerSettings(hostname: hostname, port: port)
}

func startServer(settings: ServerSettings, onReady: @escaping @Sendable () -> Void) {
  Task.detached {
    do {
      let app = try await buildApplication(settings: settings) {
        onReady()
      }
      try await app.run()
    } catch {
      print("Hummingbird server failed: \(error)")
      onReady()
    }
  }
}

func buildApplication(
  settings: ServerSettings,
  onServerRunning: @escaping @Sendable () -> Void = {}
) async throws -> some ApplicationProtocol {
  var logger = Logger(label: "{% package_name %}")
  logger.logLevel = .info

  let assets = AssetBundle(moduleName: "{% swift_module_name %}")
  let router = Router()

  router.get("/") { _, _ in
    assetResponse(assets: assets, path: "index.html", fallbackToIndex: false)
  }

  router.get("**") { request, _ in
    assetResponse(assets: assets, path: request.uri.path, fallbackToIndex: true)
  }

  let config = ApplicationConfiguration(
    address: .hostname(settings.hostname, port: settings.port),
    serverName: "{% package_name %}"
  )

  let app = Application(
    router: router,
    configuration: config,
    onServerRunning: { _ in onServerRunning() },
    logger: logger
  )

  return app
}

private func assetResponse(assets: AssetBundle, path: String, fallbackToIndex: Bool) -> Response {
  if let asset = assets.loadAsset(path: path) {
    return okResponse(data: asset.data, mimeType: asset.mimeType)
  }

  if fallbackToIndex, let index = assets.loadAsset(path: "index.html") {
    return okResponse(data: index.data, mimeType: index.mimeType)
  }

  let message = "Asset not found: \(path)"
  return textResponse(status: HTTPResponse.Status.notFound, message: message)
}

private func okResponse(data: Data, mimeType: String) -> Response {
  var buffer = ByteBufferAllocator().buffer(capacity: data.count)
  buffer.writeBytes(data)
  return Response(
    status: .ok,
    headers: [.contentType: mimeType],
    body: .init(byteBuffer: buffer)
  )
}

private func textResponse(status: HTTPResponse.Status, message: String) -> Response {
  var buffer = ByteBufferAllocator().buffer(capacity: message.utf8.count)
  buffer.writeBytes(message.utf8)
  return Response(
    status: status,
    headers: [.contentType: "text/plain"],
    body: .init(byteBuffer: buffer)
  )
}

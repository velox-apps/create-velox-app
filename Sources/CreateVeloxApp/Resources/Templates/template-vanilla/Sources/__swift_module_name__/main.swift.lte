import Foundation
import VeloxRuntimeWry

// MARK: - Asset Bundle

struct AssetBundle {
  let assetRoots: [URL]

  init() {
    let fileManager = FileManager.default
    var candidates: [URL] = []

    if let bundleURL = Bundle.module.resourceURL?.appendingPathComponent("assets") {
      candidates.append(bundleURL)
    }

    let executableURL = URL(fileURLWithPath: CommandLine.arguments[0])
    let executableDir = executableURL.deletingLastPathComponent()
    candidates.append(executableDir.appendingPathComponent("assets"))

    let cwd = URL(fileURLWithPath: fileManager.currentDirectoryPath)
    let sourceAssets = cwd
      .appendingPathComponent("Sources")
      .appendingPathComponent("{% swift_module_name %}")
      .appendingPathComponent("Resources")
      .appendingPathComponent("assets")
    candidates.append(sourceAssets)

    let existing = candidates.filter { candidate in
      fileManager.fileExists(atPath: candidate.appendingPathComponent("index.html").path)
    }

    assetRoots = existing.isEmpty ? candidates : existing
  }

  func mimeType(for path: String) -> String {
    let ext = (path as NSString).pathExtension.lowercased()
    switch ext {
    case "html", "htm":
      return "text/html"
    case "css":
      return "text/css"
    case "js":
      return "application/javascript"
    case "json":
      return "application/json"
    case "png":
      return "image/png"
    case "jpg", "jpeg":
      return "image/jpeg"
    case "gif":
      return "image/gif"
    case "svg":
      return "image/svg+xml"
    case "ico":
      return "image/x-icon"
    case "woff":
      return "font/woff"
    case "woff2":
      return "font/woff2"
    case "ttf":
      return "font/ttf"
    default:
      return "application/octet-stream"
    }
  }

  func loadAsset(path: String) -> (data: Data, mimeType: String)? {
    var normalizedPath = path
    if normalizedPath.hasPrefix("/") {
      normalizedPath = String(normalizedPath.dropFirst())
    }

    if normalizedPath.isEmpty {
      normalizedPath = "index.html"
    }

    for root in assetRoots {
      let fullPath = root.appendingPathComponent(normalizedPath)
      if let data = try? Data(contentsOf: fullPath) {
        let mime = mimeType(for: normalizedPath)
        return (data, mime)
      }
    }

    return nil
  }
}

// MARK: - Command Handler

func greet(name: String) -> String {
  "Hello \(name), You have been greeted from Swift!"
}

func handleInvoke(request: VeloxRuntimeWry.CustomProtocol.Request) -> VeloxRuntimeWry.CustomProtocol.Response? {
  guard let url = URL(string: request.url) else {
    return errorResponse(message: "Invalid URL")
  }

  let command = url.path.trimmingCharacters(in: CharacterSet(charactersIn: "/"))
  var args: [String: Any] = [:]

  if !request.body.isEmpty,
     let json = try? JSONSerialization.jsonObject(with: request.body) as? [String: Any] {
    args = json
  }

  switch command {
  case "greet":
    let name = args["name"] as? String ?? "World"
    let result = greet(name: name)
    return jsonResponse(["result": result])
  default:
    return errorResponse(message: "Unknown command: \(command)")
  }
}

func jsonResponse(_ data: [String: Any]) -> VeloxRuntimeWry.CustomProtocol.Response {
  let jsonData = (try? JSONSerialization.data(withJSONObject: data)) ?? Data()
  return VeloxRuntimeWry.CustomProtocol.Response(
    status: 200,
    headers: ["Content-Type": "application/json", "Access-Control-Allow-Origin": "*"],
    mimeType: "application/json",
    body: jsonData
  )
}

func errorResponse(message: String) -> VeloxRuntimeWry.CustomProtocol.Response {
  let error: [String: Any] = ["error": message]
  let jsonData = (try? JSONSerialization.data(withJSONObject: error)) ?? Data()
  return VeloxRuntimeWry.CustomProtocol.Response(
    status: 400,
    headers: ["Content-Type": "application/json", "Access-Control-Allow-Origin": "*"],
    mimeType: "application/json",
    body: jsonData
  )
}

// MARK: - Application Entry Point

func main() {
  guard Thread.isMainThread else {
    fatalError("This app must run on the main thread")
  }

  guard let eventLoop = VeloxRuntimeWry.EventLoop() else {
    fatalError("Failed to create event loop")
  }

  #if os(macOS)
  eventLoop.setActivationPolicy(.regular)
  #endif

  let ipcProtocol = VeloxRuntimeWry.CustomProtocol(scheme: "ipc") { request in
    handleInvoke(request: request)
  }

  let windowConfig = VeloxRuntimeWry.WindowConfiguration(
    width: 800,
    height: 600,
    title: "Welcome to \(VeloxConfig.productName)!"
  )

  guard let window = eventLoop.makeWindow(configuration: windowConfig) else {
    fatalError("Failed to create window")
  }

  let devURL = ProcessInfo.processInfo.environment["VELOX_DEV_URL"]
  let webviewConfig: VeloxRuntimeWry.WebviewConfiguration

  if let devURL {
    webviewConfig = VeloxRuntimeWry.WebviewConfiguration(
      url: devURL,
      customProtocols: [ipcProtocol]
    )
  } else {
    let assets = AssetBundle()
    let appProtocol = VeloxRuntimeWry.CustomProtocol(scheme: "app") { request in
      guard let url = URL(string: request.url) else {
        return VeloxRuntimeWry.CustomProtocol.Response(
          status: 400,
          headers: ["Content-Type": "text/plain"],
          body: Data("Invalid URL".utf8)
        )
      }

      if let asset = assets.loadAsset(path: url.path) {
        return VeloxRuntimeWry.CustomProtocol.Response(
          status: 200,
          headers: ["Content-Type": asset.mimeType],
          mimeType: asset.mimeType,
          body: asset.data
        )
      }

      return VeloxRuntimeWry.CustomProtocol.Response(
        status: 404,
        headers: ["Content-Type": "text/plain"],
        body: Data("Asset not found: \(url.path)".utf8)
      )
    }

    webviewConfig = VeloxRuntimeWry.WebviewConfiguration(
      url: "app://localhost/",
      customProtocols: [ipcProtocol, appProtocol]
    )
  }

  guard let webview = window.makeWebview(configuration: webviewConfig) else {
    fatalError("Failed to create webview")
  }

  _ = window.setVisible(true)
  _ = window.focus()
  _ = webview.show()

  #if os(macOS)
  eventLoop.showApplication()
  #endif

  final class AppState: @unchecked Sendable {
    var shouldExit = false
  }

  let state = AppState()

  while !state.shouldExit {
    eventLoop.pump { event in
      switch event {
      case .windowCloseRequested, .userExit:
        state.shouldExit = true
        return .exit
      default:
        return .wait
      }
    }
  }
}

main()
